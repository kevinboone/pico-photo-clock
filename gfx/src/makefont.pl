#!/usr/bin/perl -w

#
# This utility generates C source and header files containing font data
# in JPEG format. It uses ImageMagick and xsd.
#
# Copyright (c)2023 Kevin Boone, GPLv3.0
#

use strict;

# Define the font name and size. Note that this font must be installed!
#   Use "identify -list font" to get a list of fonts that ImageMagick can use.
# Note that only the size of the largest font glyph is stored in the output
#   C file, making this utility only suitable for use with fixed-pitch fonts.
#   These tend to have 'mono' in their names (except Courier).
#my $FONT="courier-bold";
my $FONT="dejavu-sans-mono";
my $SIZE=36;
# Crop setting needs to be tailored to the size. The reason to crop is to
#   remove the large amount of empty space that IM sometimes generates 
#   around characters. This space is just a waste of memory
#my $CROP ="-gravity South -crop 100%x80%+0+0";
my $CROP ="";

# Font names often contain a '-' character. We can't use this as the name of
#   a C identifier, because it's a minus sign, so change to an underscore.
my $SANITIZED_FONT = $FONT;
$SANITIZED_FONT =~ tr/-/_/;

# Remove any old JPEG files
system ("rm -f *.jpg");

my $c_file="${SANITIZED_FONT}_${SIZE}.c";
my $h_file="${SANITIZED_FONT}_${SIZE}.h";

printf (".c file is ${c_file}\n");
printf (".h file is ${h_file}\n");

# We will update max_width and max_height as we loop through the characters.
# This will give us the size in pixels of a box that will contain any
#   glyph in the font.
my $max_width = 1;
my $max_height = 1;

# Use ImageMagick to write out each character as a JPEG file
for (my $i = 32; $i < 127; ++$i)
  {
  printf ("Generating JPEG image for character 0x%02x\n", $i);
  my $jpg_name = sprintf ("%s_%s_%02x.jpg", $SANITIZED_FONT, $SIZE, $i); 
  my $label = sprintf ("%c", $i);
  # Special treatment for characters that need to be escaped in some way
  if ($i == 32) { $label = "\\ "; } # space
  if ($i == 34) { $label = "\\\""; } # double-quote
  if ($i == 92) { $label = "\\\\\\\\"; } ## backslash -- Wow!
  if ($i == 96) { $label = "\\\`"; } # back-tick
  # Quietly remove the underscore, because ImageMagick seems to draw it really
  #   wide, and that upsets the overall text layout.
  if ($i == 95) { $label = "\\ "; } # back-tick
  my $command = sprintf ("convert -background black -fill white -colorspace Gray  -font %s -pointsize %s %s \"label:%s\" %s", 
      $FONT, $SIZE, $CROP, $label, $jpg_name);
  system ("$command");

  # Use 'file' to tell us the size of the JPEG image for each glyph. Note that
  #   we only tell ImageMagick a font size in points. Some experimentation is
  #   necessary to get a font specification of the right size in pixels.
  my $fileinfo = `file $jpg_name`;
  $fileinfo =~ /, (\d+)x(\d+)/;
  my $width=$1;
  my $height=$2;
  printf ("This character is %dx%d\n", $width, $height);
  if ($width > $max_width) { $max_width = $width; }
  if ($height > $max_height) { $max_height = $height; }
  }

# Write the header of the C file
open OUT_C, ">${c_file}" or die "Can't open ${c_file} for writing\n";
printf OUT_C "// This file is automatically generated. Do not edit\n";
printf OUT_C "#include \"${h_file}\"\n";
close OUT_C;

for (my $i = 32; $i < 127; ++$i)
  {
  my $jpg_name = sprintf ("%s_%s_%02x.jpg", $SANITIZED_FONT, $SIZE, $i); 
  my $command = sprintf ("xxd -i %s >> %s", $jpg_name, $c_file); 
  system (${command});
  }

# Write the main array definitions into the C file
open OUT_C, ">>${c_file}" or die "Can't open ${c_file} for writing\n";

printf OUT_C "unsigned int *${SANITIZED_FONT}_${SIZE}_length[] = \n  {\n";

for (my $i = 32; $i < 127; ++$i)
  {
  my $s = sprintf ("  &%s_%s_%02x_jpg_len", $SANITIZED_FONT, $SIZE, $i);
  printf OUT_C "$s";
  if ($i != 126) { print OUT_C ","; }
  printf OUT_C "\n";
  }

printf OUT_C "  };\n\n";

printf OUT_C "unsigned char *${SANITIZED_FONT}_${SIZE}_data[] = \n  {\n";

for (my $i = 32; $i < 127; ++$i)
  {
  my $s = sprintf ("  %s_%s_%02x_jpg", $SANITIZED_FONT, $SIZE, $i);
  printf OUT_C "$s";
  if ($i != 126) { print OUT_C ","; }
  printf OUT_C "\n";
  }

printf OUT_C "  };\n\n";

printf OUT_C "unsigned int ${SANITIZED_FONT}_${SIZE}_width=${max_width};\n";
printf OUT_C "unsigned int ${SANITIZED_FONT}_${SIZE}_height=${max_height};\n";

close OUT_C;

open OUT_H, ">${h_file}" or die "Can't open ${h_file} for writing\n";
printf OUT_H "// This file is automatically generated. Do not edit\n";
printf OUT_H "extern unsigned int *${SANITIZED_FONT}_${SIZE}_length[95];\n";
printf OUT_H "extern unsigned char *${SANITIZED_FONT}_${SIZE}_data[95];\n";
printf OUT_H "extern unsigned int ${SANITIZED_FONT}_${SIZE}_width;\n";
printf OUT_H "extern unsigned int ${SANITIZED_FONT}_${SIZE}_height;\n";

close OUT_C;

# Clean up
system ("rm -f *.jpg");



